from lib import *


@dataclass
class Input:
    n: int

    @classmethod
    def from_seed(cls, seed) -> Self:
        """
        Generate a challenge input from a seed. This seed is usually a string or an integer, but
        could be any value. This function should be deterministic, i.e. if called several times with
        the same seed, it should always generate the same challenge input.
        """

        # initialize the random number generate with the given seed
        random.seed(seed)

        # generate a random challenge input and return it
        n = random.randint(10, 10000)
        return cls(n)

    def serialize(self) -> str:
        """
        Convert an Input object into the string that is fed into the user's solution program via stdin.
        """

        return str(self.n)

    def data(self):
        """
        Return additional information that is fed into the `Output.check` function when checking the output
        of the user's solution program. This information is only available to this evaluator and
        not shared with the user. You can use this to calculate the expected challenge output or to
        return other information that are needed to check the solution's output (e.g. in case your
        evaluator should accept more than one specific output).
        """

        # in this case we just calculate and return the expected answer
        return self.n * (self.n + 1) // 2


@dataclass
class Output:
    sum: int

    @classmethod
    def deserialize(cls, output: str, log) -> Self:
        """
        Parse the output of the user's solution program. Raising an error here will result in the
        `INVALID_OUTPUT_FORMAT` verdict. You can use the `log` function to provide additional
        information on why parsing the output failed.
        """

        output = output.strip()
        if not output.isnumeric():
            log("output is not a single integer")
            raise ValueError

        s = int(output)
        if s < 0:
            log("output is not a positive integer")
            raise ValueError

        return cls(s)

    def check(self, data, log) -> bool:
        """
        Determine whether the output of the user's solution program (self) is correct and should be
        accepted. `data` is the value generated by the `Input.data` function for the corresponding
        challenge input. In case of an incorrect output you can use the `log` function to provide
        additional information on why the answer was wrong.
        """

        if self.sum < data:
            log("too low")
            return False  # `WRONG_ANSWER`
        if self.sum > data:
            log("too high")
            return False  # `WRONG_ANSWER`

        return True  # `OK`


# Provide example inputs that are shown to the user. The corresponding outputs and explanations are
# generated automatically using the provided sample solution. `example` expects a single function
# that returns a single Input object. You can either call it directly for example with an anonymous
# `lambda` function, or you can use it as a decorator (`@example`) if you need to generate more
# complex examples.
example(lambda: Input(5))
example(lambda: Input(10))
example(lambda: Input.from_seed(0))
example(lambda: Input.from_seed(1))
example(lambda: Input.from_seed(2))


@example
def more_complex_example():
    n = 7 * 191
    return Input(n)


def prepare(environment: str, code: str, data, log) -> str:
    """
    This function is called after a challenge input has been generated and before the user's solution
    program is run. `environment` is the name of the environment of the user's solution (e.g. "rust"
    or "python") and `code` is the actual code the user has uploaded. Again, `data` is the value
    generated by the `Input.data` function, just like in `Output.check`. The string this function
    returns will replace the users code before running it. Raising an error here will result in the
    `PRE_CHECK_FAILED` verdict. The purpose of this function is to enfoce additional contraints on
    solution programs and to prepare the environment in which the user's code will run.
    """

    # if environment == "python" and len(code) > 64:
    #     log("your python program is too long")
    #     raise ValueError

    # if environment in ["javascript", "typescript"]:
    #     code = f'console.error("Hello from {environment}!")\n' + code

    return code


# call the library's main function which implements the evaluator api using the provided Input and Output classes
main(Input, Output, prepare)
